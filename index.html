<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>City Explorer</title>
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <!-- Turf.js for geometry math -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <!-- Icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0f1115;
      --card:#171a20;
      --muted:#8a90a5;
      --accent:#4ade80; /* green */
      --accent-2:#60a5fa; /* blue */
      --danger:#ef4444;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:#e5e7eb;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji";}
    #app{height:100%;display:flex;flex-direction:column;}

    /* Top bar */
    .topbar{position:relative;z-index:1000;display:flex;align-items:center;gap:.75rem;padding:.75rem env(safe-area-inset-right) .75rem env(safe-area-inset-left);background:linear-gradient(180deg, rgba(23,26,32,.95), rgba(23,26,32,.6));backdrop-filter: blur(6px);border-bottom:1px solid rgba(255,255,255,.06);}    
    .brand{font-weight:700;letter-spacing:.2px;}
    .city{font-weight:600;color:#fff;}
    .muted{color:var(--muted);font-weight:500;}
    .grow{flex:1}

    /* Buttons */
    .btn{appearance:none;border:0;background:#222733;color:#e5e7eb;padding:.6rem .9rem;border-radius:14px;font-weight:600;letter-spacing:.2px;box-shadow:0 1px 0 rgba(255,255,255,.06) inset, 0 8px 20px rgba(0,0,0,.25);transition:transform .06s ease, box-shadow .2s ease, background .2s ease;}
    .btn:active{transform:translateY(1px)}
    .btn-primary{background:linear-gradient(180deg, #1f2937, #111827);border:1px solid rgba(255,255,255,.08);} 
    .btn-accent{background:linear-gradient(180deg, #2dd4bf, #10b981);color:#04200f;border:0;}
    .btn-danger{background:linear-gradient(180deg, #f87171, #ef4444);color:#210808;border:0;}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,.12)}

    /* Map container */
    #map{flex:1;position:relative;}
    .leaflet-container{background:#0b0c10 !important;}

    /* Grey reveal mask canvas */
    #revealCanvas{position:absolute;inset:0;pointer-events:none;z-index:800;}

    /* Bottom panel */
    .panel{position:relative;z-index:1000;padding:.6rem env(safe-area-inset-right) .9rem env(safe-area-inset-left);background:linear-gradient(180deg, rgba(23,26,32,.0), rgba(23,26,32,.85));}
    .statline{display:flex;align-items:center;gap:.75rem;}
    .progress-wrap{flex:1;height:12px;background:#1c2130;border-radius:999px;overflow:hidden;border:1px solid rgba(255,255,255,.08)}
    .progress{height:100%;width:0%;background:linear-gradient(90deg, var(--accent), var(--accent-2));transition:width .4s ease}

    .chip{font-size:.8rem;padding:.35rem .6rem;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.2)}
    .legend{display:flex;gap:.5rem;align-items:center;color:#bfc6d6;font-size:.85rem;margin-top:.5rem}
    .dot{width:10px;height:10px;border-radius:999px;background:var(--accent)}

    /* Toast */
    .toast{position:fixed;left:50%;bottom:90px;transform:translateX(-50%);background:#111827;border:1px solid rgba(255,255,255,.12);padding:.7rem 1rem;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);z-index:2000;display:none}

    /* Mobile friendly tap targets */
    .controls{display:flex;gap:.5rem}
    @media (max-width:480px){
      .brand{display:none}
    }
  </style>
</head>
<body>
<div id="app">
  <div class="topbar">
    <div class="brand">üó∫Ô∏è City Explorer</div>
    <div class="grow muted" id="cityLabel">Detecting city‚Ä¶</div>
    <div class="controls">
      <button id="startBtn" class="btn btn-accent">Start</button>
      <button id="pauseBtn" class="btn btn-ghost">Pause</button>
      <button id="resetBtn" class="btn btn-danger">Reset</button>
    </div>
  </div>

  <div id="map"></div>
  <canvas id="revealCanvas"></canvas>

  <div class="panel">
    <div class="statline">
      <div class="chip" id="distanceChip">0.00 km</div>
      <div class="chip" id="tilesChip">0 tiles</div>
      <div class="progress-wrap"><div class="progress" id="progressBar"></div></div>
      <div class="chip" id="progressLabel">0%</div>
    </div>
    <div class="legend"><span class="dot"></span> Areas you‚Äôve unlocked</div>
  </div>

  <div class="toast" id="toast"></div>
</div>

<script>
(function(){
  const STORAGE_KEY = 'cityExplorer.v1';
  const TILE_ZOOM = 16; // balance detail/perf
  const REVEAL_RADIUS_PX = 60; // width of revealed path on screen
  let state = {
    tracking:false,
    watchId:null,
    path:[], // {lat,lng,t}
    visitedTiles:new Set(),
    city:null, // {name, country, polygon, bbox, tileKeys:Set, tileCount}
    distanceMeters:0,
  };

  /* --- Map setup --- */
  const map = L.map('map', { zoomControl:false, attributionControl:true, inertia:true });
  const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(map);
  L.control.zoom({ position:'topright' }).addTo(map);

  // Canvas overlay for grey mask reveal
  const canvas = document.getElementById('revealCanvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas(){
    const r = devicePixelRatio || 1;
    canvas.width = canvas.clientWidth * r;
    canvas.height = canvas.clientHeight * r;
    ctx.setTransform(r,0,0,r,0,0);
    drawMask();
  }
  const ro = new ResizeObserver(resizeCanvas);
  ro.observe(document.getElementById('map'));

  map.on('move zoom', drawMask);

  function drawMask(){
    // Ensure canvas matches container size
    const rect = canvas.getBoundingClientRect();
    if(canvas.width !== rect.width*(devicePixelRatio||1)) resizeCanvas();

    // Fill grey veil
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = 'rgba(30,33,43,0.88)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Erase where user walked
    ctx.globalCompositeOperation = 'destination-out';
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.lineWidth = REVEAL_RADIUS_PX;

    if(state.path.length){
      ctx.beginPath();
      for(let i=0;i<state.path.length;i++){
        const p = map.latLngToContainerPoint([state.path[i].lat, state.path[i].lng]);
        if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();

      // Also punch circular holes at each point to avoid gaps
      for(const pt of state.path){
        const p = map.latLngToContainerPoint([pt.lat, pt.lng]);
        ctx.beginPath();
        ctx.arc(p.x, p.y, REVEAL_RADIUS_PX/2, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // Done, restore default comp mode
    ctx.globalCompositeOperation = 'source-over';
  }

  /* --- UI helpers --- */
  const cityLabel = document.getElementById('cityLabel');
  const progressBar = document.getElementById('progressBar');
  const progressLabel = document.getElementById('progressLabel');
  const distanceChip = document.getElementById('distanceChip');
  const tilesChip = document.getElementById('tilesChip');
  const toastEl = document.getElementById('toast');
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.style.display = 'block';
    setTimeout(()=>toastEl.style.display='none', 2200);
  }

  /* --- Storage --- */
  function save(){
    const payload = {
      tracking: state.tracking,
      path: state.path,
      visitedTiles: Array.from(state.visitedTiles),
      city: state.city ? { name: state.city.name, country: state.city.country, bbox: state.city.bbox, polygon: state.city.polygon, tileKeys: Array.from(state.city.tileKeys||[]), tileCount: state.city.tileCount||0 } : null,
      distanceMeters: state.distanceMeters,
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }
  function load(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    try{
      const data = JSON.parse(raw);
      state.tracking = false; // never auto-resume
      state.path = data.path||[];
      state.visitedTiles = new Set(data.visitedTiles||[]);
      state.distanceMeters = data.distanceMeters||0;
      if(data.city){
        state.city = {
          name: data.city.name,
          country: data.city.country,
          bbox: data.city.bbox,
          polygon: data.city.polygon,
          tileKeys: new Set(data.city.tileKeys||[]),
          tileCount: data.city.tileCount||0
        };
        updateProgress();
      }
    }catch(e){ console.warn('Failed to load saved state', e); }
  }

  /* --- Geolocation tracking --- */
  function startTracking(){
    if(state.watchId) return;
    if(!('geolocation' in navigator)){
      toast('Geolocation not supported');
      return;
    }
    state.tracking = true; save();
    state.watchId = navigator.geolocation.watchPosition(onPosition, onGeoError, {
      enableHighAccuracy:true,
      maximumAge: 5000,
      timeout: 20000
    });
    toast('Tracking started');
  }
  function pauseTracking(){
    if(state.watchId){
      navigator.geolocation.clearWatch(state.watchId);
      state.watchId = null;
      state.tracking = false; save();
      toast('Tracking paused');
    }
  }
  function resetAll(){
    pauseTracking();
    state.path = [];
    state.visitedTiles = new Set();
    state.distanceMeters = 0;
    if(state.city){ state.city.tileKeys = new Set(); state.city.tileCount = state.city.tileCount||0; }
    save();
    drawMask();
    updateProgress();
  }

  function onPosition(pos){
    const { latitude:lat, longitude:lng } = pos.coords;
    const ll = L.latLng(lat, lng);

    if(!map._loaded){
      map.setView(ll, 16);
    }

    // append to path if far enough
    const last = state.path[state.path.length-1];
    if(!last || distanceMeters(last.lat,last.lng,lat,lng) > 5){
      state.path.push({lat, lng, t: Date.now()});
      if(last){ state.distanceMeters += distanceMeters(last.lat,last.lng,lat,lng); }

      // mark visited tile
      const tile = latLngToTile(lat,lng,TILE_ZOOM);
      const key = `${TILE_ZOOM}/${tile.x}/${tile.y}`;
      state.visitedTiles.add(key);

      drawMask();
      updateProgress();
      save();
    }
  }
  function onGeoError(err){
    console.warn(err);
    toast(err.message || 'Location error');
  }

  /* --- Progress calculation (tile-based vs city polygon) --- */
  function updateProgress(){
    distanceChip.textContent = `${(state.distanceMeters/1000).toFixed(2)} km`;
    tilesChip.textContent = `${state.visitedTiles.size} tiles`;

    if(!state.city || !state.city.tileCount){
      progressBar.style.width = '0%';
      progressLabel.textContent = '0%';
      return;
    }
    // Restrict visited to those inside city tile set
    let insideCount = 0;
    for(const k of state.visitedTiles){ if(state.city.tileKeys.has(k)) insideCount++; }
    const pct = Math.min(100, ((insideCount / state.city.tileCount) * 100) || 0);
    progressBar.style.width = pct.toFixed(1)+'%';
    progressLabel.textContent = pct.toFixed(1)+'%';
  }

  // Build city tile set once we know city polygon
  async function ensureCityTiles(){
    if(!state.city || !state.city.polygon) return;
    if(state.city.tileKeys && state.city.tileKeys.size>0 && state.city.tileCount>0){ updateProgress(); return; }

    const bbox = turf.bbox(state.city.polygon);
    const [minLng,minLat,maxLng,maxLat] = bbox;
    const minTile = latLngToTile(minLat,minLng,TILE_ZOOM);
    const maxTile = latLngToTile(maxLat,maxLng,TILE_ZOOM);

    const keys = new Set();
    for(let x=minTile.x; x<=maxTile.x; x++){
      for(let y=minTile.y; y<=maxTile.y; y++){
        const center = tileCenterLatLng(x,y,TILE_ZOOM);
        const p = turf.point([center.lng, center.lat]);
        if(turf.booleanPointInPolygon(p, state.city.polygon)){
          keys.add(`${TILE_ZOOM}/${x}/${y}`);
        }
      }
    }
    state.city.tileKeys = keys;
    state.city.tileCount = keys.size;
    save();
    updateProgress();
  }

  /* --- City detection & boundary fetch from Nominatim --- */
  async function detectCityAndFetchBoundary(lat,lng){
    try{
      cityLabel.textContent = 'Detecting city‚Ä¶';
      // Reverse geocode to get city/town + country
      const rev = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lng}`).then(r=>r.json());
      const addr = rev.address || {};
      const name = addr.city || addr.town || addr.village || addr.municipality || addr.county;
      const country = addr.country || '';

      if(!name){
        cityLabel.textContent = 'Unknown area';
        return;
      }

      // Search boundary polygon
      const q = encodeURIComponent(`${name}, ${country}`);
      const res = await fetch(`https://nominatim.openstreetmap.org/search?format=jsonv2&polygon_geojson=1&limit=1&q=${q}`).then(r=>r.json());
      if(!res || !res.length || !res[0].geojson){
        cityLabel.textContent = name;
        state.city = { name, country, polygon:null, bbox:null, tileKeys:new Set(), tileCount:0 };
        save();
        return;
      }
      const poly = res[0].geojson; // may be MultiPolygon
      const bbox = res[0].boundingbox ? res[0].boundingbox.map(Number) : null;
      // Normalize to Feature
      const feature = { type:'Feature', properties:{ name }, geometry: poly };
      state.city = { name, country, polygon:feature, bbox, tileKeys:new Set(), tileCount:0 };
      cityLabel.innerHTML = `<span class="city">${name}</span> <span class="muted">${country}</span>`;
      save();
      ensureCityTiles();
    }catch(e){
      console.warn(e);
      cityLabel.textContent = 'City boundary unavailable';
    }
  }

  /* --- Utilities --- */
  function distanceMeters(lat1,lon1,lat2,lon2){ // Haversine
    const R=6371000; const toRad = d=>d*Math.PI/180;
    const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(a));
  }
  function latLngToTile(lat,lng,zoom){
    const x = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1/Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
    return {x,y};
  }
  function tileCenterLatLng(x,y,zoom){
    const n = Math.pow(2, zoom);
    const lon_deg = x / n * 360 - 180;
    const lat_rad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
    const lat_deg = lat_rad * 180 / Math.PI;
    return {lat:lat_deg, lng:lon_deg};
  }

  /* --- Wire up UI --- */
  document.getElementById('startBtn').addEventListener('click', startTracking);
  document.getElementById('pauseBtn').addEventListener('click', pauseTracking);
  document.getElementById('resetBtn').addEventListener('click', ()=>{
    if(confirm('Clear your path and progress?')) resetAll();
  });

  /* --- Boot --- */
  load();

  // If we have prior path, draw and center
  if(state.path.length){
    const last = state.path[state.path.length-1];
    map.setView([last.lat,last.lng], 16);
    drawMask();
  }

  // Try geolocate once for center & city
  if('geolocation' in navigator){
    navigator.geolocation.getCurrentPosition(async (pos)=>{
      const {latitude:lat, longitude:lng} = pos.coords;
      map.setView([lat,lng], 16);
      drawMask();
      if(!state.city){ await detectCityAndFetchBoundary(lat,lng); }
      else { cityLabel.textContent = state.city.name + (state.city.country? `, ${state.city.country}` : ''); ensureCityTiles(); }
    }, (err)=>{
      console.warn(err); toast('Allow location to start exploring');
    }, { enableHighAccuracy:true, timeout:20000 });
  }
})();
</script>
</body>
</html>
