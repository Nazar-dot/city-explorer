<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>City Explorer ‚Äî Fog of War</title>

  <!-- Leaflet & Turf (CDN) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14; --card:#121823; --muted:#94a3b8; --text:#e8eef7; --accent:#4cc9f0; --accent2:#22c55e; --warn:#f43f5e;
    }
    *{box-sizing:border-box;}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #app{display:flex;flex-direction:column;height:100dvh;}

    /* Header */
    .topbar{
      display:flex;align-items:center;gap:10px;padding:10px 12px;background:linear-gradient(180deg,#0b0f14 0%, #0b0f1400 100%);
      position:sticky;top:0;z-index:1000;backdrop-filter:blur(6px);
    }
    .brand{font-weight:700;letter-spacing:.3px;}
    .chip{font-size:12px;color:#cbd5e1;background:#0f172a;border:1px solid #1f2937;padding:4px 8px;border-radius:999px}

    /* Map */
    #map{flex:1;min-height:320px}
    .leaflet-container{background:#0f172a;}
    .leaflet-control-attribution{display:none;}

    /* Controls card */
    .panel{
      position:fixed;left:0;right:0;bottom:0;z-index:1001;
      padding:12px;display:grid;gap:10px;
    }
    .card{
      background:linear-gradient(180deg,#0f172a 0%,#0b1220 100%);
      border:1px solid #1e293b;border-radius:16px;padding:12px;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .row.space{justify-content:space-between}
    .btn{
      appearance:none;border:none;border-radius:12px;padding:10px 14px;font-weight:600;color:#0b0f14;background:var(--accent);
      box-shadow:0 6px 16px rgba(76,201,240,.2);transition:transform .06s ease,filter .2s ease;
    }
    .btn:active{transform:translateY(1px)}
    .btn.secondary{background:#0b1220;color:#e2e8f0;border:1px solid #1f2a3b}
    .btn.success{background:var(--accent2);box-shadow:0 6px 16px rgba(34,197,94,.25)}
    .btn.warn{background:var(--warn);color:white}
    .hint{font-size:12px;color:var(--muted)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}

    /* Progress ring */
    .ring{position:relative;width:60px;height:60px}
    .ring svg{transform:rotate(-90deg)}
    .ring .num{position:absolute;inset:0;display:grid;place-items:center;font-size:12px;font-weight:700}

    /* Permission banner */
    .perm{
      position:fixed;inset:auto 12px 120px 12px;z-index:1002;background:#0b1220;border:1px solid #1f2937;border-radius:14px;
      padding:12px;display:none;gap:8px
    }
    .perm.show{display:flex;align-items:center;justify-content:space-between}
    .link{color:var(--accent)}
  </style>
</head>
<body>
<div id="app">
  <div class="topbar">
    <div class="brand">üó∫Ô∏è City Explorer</div>
    <span class="chip">Mobile ‚Ä¢ OSM</span>
    <span class="chip" id="status">Idle</span>
  </div>

  <div id="map"></div>

  <!-- Permission banner -->
  <div id="perm" class="perm">
    <div>
      <div style="font-weight:700">–î–æ–∑–≤–æ–ª–∏ –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—é</div>
      <div class="hint">–ù–∞—Ç–∏—Å–Ω–∏ ¬´–£–≤—ñ–º–∫–Ω—É—Ç–∏ –≥–µ–æ–ª–æ–∫–∞—Ü—ñ—é¬ª, —Ç–æ–¥—ñ —Å–∏–Ω—è —Ç–æ—á–∫–∞ –∑‚Äô—è–≤–∏—Ç—å—Å—è –Ω–∞ –º–∞–ø—ñ.</div>
    </div>
    <button id="btnEnable" class="btn">–£–≤—ñ–º–∫–Ω—É—Ç–∏</button>
  </div>

  <!-- Controls -->
  <div class="panel">
    <div class="card">
      <div class="row space">
        <div class="row">
          <div class="ring"><svg width="60" height="60">
            <circle cx="30" cy="30" r="26" stroke="#1f2937" stroke-width="6" fill="none"></circle>
            <circle id="ring" cx="30" cy="30" r="26" stroke="var(--accent)" stroke-width="6" fill="none" stroke-linecap="round" stroke-dasharray="163.36" stroke-dashoffset="163.36"></circle>
          </svg><div class="num"><span id="pct">0%</span></div></div>
          <div>
            <div style="font-weight:700">–ü—Ä–æ–≥—Ä–µ—Å –º—ñ—Å—Ç–∞</div>
            <div class="hint"><span id="dist">0.00 –∫–º</span> ‚Ä¢ —Ç–æ—á–Ω—ñ—Å—Ç—å <span id="acc">‚Äî</span></div>
          </div>
        </div>
        <div class="row">
          <button id="btnStart" class="btn success">–ü–æ—á–∞—Ç–∏</button>
          <button id="btnPause" class="btn secondary">–ü–∞—É–∑–∞</button>
        </div>
      </div>
      <div class="grid" style="margin-top:8px">
        <button id="btnSetArea" class="btn secondary">–í—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –∑–æ–Ω—É (–ø–æ—Ç–æ—á–Ω–∏–π –≤–∏–¥)</button>
        <button id="btnReset" class="btn warn">–°–∫–∏–Ω—É—Ç–∏ –≤—Å–µ</button>
      </div>
      <div class="hint" style="margin-top:6px">–ü–æ—Ä–∞–¥–∞: –Ω–∞–≤–µ–¥–∏ –ø–æ—Ç—Ä—ñ–±–Ω—É —á–∞—Å—Ç–∏–Ω—É –º—ñ—Å—Ç–∞ —Ç–∞ –Ω–∞—Ç–∏—Å–Ω–∏ ¬´–í—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –∑–æ–Ω—É¬ª. –ü—Ä–æ–≥—Ä–µ—Å —Ä–∞—Ö—É—î—Ç—å—Å—è –≤ –º–µ–∂–∞—Ö —Ü—ñ—î—ó –∑–æ–Ω–∏.</div>
    </div>
  </div>
</div>

<script>
(function(){
  // ---- State ----
  let map, base, fogPoly, watchId = null, tracking = false;
  const holes = []; // array of hole rings [ [ [lat,lng], ... ] ]
  const points = []; // visited points {lat,lng,t}
  const RADIUS_M = 60;           // reveal radius (meters) per point
  const STEP_MIN_METERS = 20;    // min distance between stored points
  const OFFSCREEN_SIZE = 600;    // canvas for area compute (pixels)
  let cityBounds = null;         // L.LatLngBounds
  let distanceMeters = 0;
  let lastPoint = null;

  // Restore from localStorage
  const saved = JSON.parse(localStorage.getItem("cx_state")||"{}");
  if(saved.city){ cityBounds = L.latLngBounds(saved.city._southWest, saved.city._northEast); }
  if(saved.points){ saved.points.forEach(p=>points.push(p)); }
  if(saved.distanceMeters){ distanceMeters = saved.distanceMeters; }
  if(saved.holes){ saved.holes.forEach(r=>holes.push(r)); }

  // ---- Map ----
  map = L.map('map', {zoomControl:false, worldCopyJump:true});
  base = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    maxZoom:19, attribution:'¬© OpenStreetMap'
  }).addTo(map);

  // Start view (try last point or default)
  if(points.length){
    const lp = points[points.length-1];
    map.setView([lp.lat, lp.lng], 16);
  }else{
    map.setView([50.4501, 30.5234], 13); // Kyiv fallback
  }

  // Blue dot (user location)
  const userMarker = L.circleMarker([0,0], {
    radius:6, color:'#3b82f6', weight:2, fillColor:'#60a5fa', fillOpacity:0.9
  }).addTo(map);

  // ---- Fog polygon (outer ring + holes) ----
  // Outer ring = whole world in Web Mercator-friendly polygon (big square)
  const OUTER = [
    [ 85, -180], [ 85, 180],
    [-85,  180], [-85, -180]
  ];
  fogPoly = L.polygon([OUTER, ...holes], {
    stroke:false, fill:true, fillOpacity:0.88, fillColor:'#0b0f14', fillRule:'evenodd'
  }).addTo(map);

  // ---- UI refs ----
  const el = s=>document.querySelector(s);
  const status = el('#status'), pct = el('#pct'), ring = el('#ring'),
        dist = el('#dist'), acc = el('#acc'),
        perm = el('#perm'), btnEnable = el('#btnEnable'),
        btnStart = el('#btnStart'), btnPause = el('#btnPause'),
        btnSetArea = el('#btnSetArea'), btnReset = el('#btnReset');

  // Progress ring helper
  const C = 2*Math.PI*26; // circumference for r=26
  ring.setAttribute('stroke-dasharray', C.toFixed(2));
  function setProgress(p){ // 0..1
    const o = Math.max(0, Math.min(1, p));
    ring.setAttribute('stroke-dashoffset', (C*(1-o)).toFixed(2));
    pct.textContent = Math.round(o*100)+'%';
  }

  // Distance UI
  function setDistance(m){
    dist.textContent = (m/1000).toFixed(2)+' –∫–º';
  }
  setDistance(distanceMeters);

  // Permission banner
  function showPerm(v){ perm.classList.toggle('show', !!v); }

  // Save state
  function save(){
    localStorage.setItem("cx_state", JSON.stringify({
      city: cityBounds ? { _southWest: cityBounds.getSouthWest(), _northEast: cityBounds.getNorthEast() } : null,
      points, distanceMeters, holes
    }));
  }

  // Add a "hole" around a point using Turf circle -> Leaflet ring
  function addHole(lat, lng){
    try{
      const circle = turf.circle([lng, lat], RADIUS_M, {steps:32, units:'meters'});
      const coords = circle.geometry.coordinates[0]; // [ [lng,lat], ... ]
      const ringLatLng = coords.map(([lo,la])=>[la,lo]);
      holes.push(ringLatLng);
      fogPoly.setLatLngs([OUTER, ...holes]);
    }catch(e){ console.error(e); }
  }

  // Haversine distance (meters)
  function distMeters(a,b){
    const R=6371000, toRad=x=>x*Math.PI/180;
    const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lng-a.lng);
    const la1=toRad(a.lat), la2=toRad(b.lat);
    const x = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(x));
  }

  // Offscreen canvas for area progress
  const off = document.createElement('canvas');
  off.width = OFFSCREEN_SIZE; off.height = OFFSCREEN_SIZE;
  const ox = off.getContext('2d');

  function mercX(lon){ return (lon+180)/360; }
  function mercY(lat){
    const rad = lat*Math.PI/180;
    return (1 - Math.log(Math.tan(rad)+1/Math.cos(rad))/Math.PI)/2;
  }

  function updateProgress(){
    if(!cityBounds){ setProgress(0); return; }
    // Prepare mapping
    const sw = cityBounds.getSouthWest(), ne = cityBounds.getNorthEast();
    const x0 = mercX(sw.lng), y1 = mercY(sw.lat);
    const x1 = mercX(ne.lng), y0 = mercY(ne.lat);
    const w = Math.max(1, (x1-x0)*off.width), h = Math.max(1, (y1-y0)*off.height);

    // meters per pixel approx
    const midLat = (sw.lat+ne.lat)/2;
    const west = {lat: midLat, lng: sw.lng}, east = {lat: midLat, lng: ne.lng};
    const north = {lat: ne.lat, lng: (sw.lng+ne.lng)/2}, south = {lat: sw.lat, lng: (sw.lng+ne.lng)/2};
    const widthM = distMeters(west, east), heightM = distMeters(north, south);
    const mppx = (widthM/w + heightM/h)/2;

    // Draw mask
    ox.clearRect(0,0,off.width,off.height);
    ox.fillStyle = '#000'; ox.globalCompositeOperation = 'source-over';
    ox.fillRect(0,0,off.width,off.height);

    ox.globalCompositeOperation = 'destination-out';
    for(const p of points){
      // convert to normalized mercator within bounds
      const nx = (mercX(p.lng)-x0)/(x1-x0);
      const ny = (mercY(p.lat)-y0)/(y1-y0);
      if(nx< -0.1||nx>1.1||ny< -0.1||ny>1.1) continue;
      const cx = nx*off.width, cy = (1-ny)*off.height;
      const pr = Math.max(1, RADIUS_M / mppx);
      ox.beginPath(); ox.arc(cx, cy, pr, 0, Math.PI*2); ox.fill();
    }
    ox.globalCompositeOperation = 'source-over';

    // Count cleared pixels
    const img = ox.getImageData(0,0,off.width,off.height).data;
    let cleared = 0;
    for(let i=3;i<img.length;i+=4){ if(img[i]===0) cleared++; } // alpha==0 => hole
    const p = cleared/(off.width*off.height);
    setProgress(p);
  }

  function inCity(latlng){
    if(!cityBounds) return true;
    return cityBounds.contains(latlng);
  }

  // Add a track point if moved enough
  function pushPoint(lat, lng, accm){
    const p = {lat,lng,t:Date.now(), acc:accm||null};
    if(lastPoint){
      const d = distMeters(lastPoint, p);
      if(d < STEP_MIN_METERS) return;
      distanceMeters += d;
      setDistance(distanceMeters);
    }
    lastPoint = p;
    points.push(p);
    addHole(lat,lng);
    save();
    updateProgress();
  }

  // ---- Geolocation ----
  function startWatch(){
    if(watchId!=null) return;
    if(!('geolocation' in navigator)){
      status.textContent = 'No geolocation';
      alert('–ì–µ–æ–ª–æ–∫–∞—Ü—ñ—è –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è —Ü–∏–º –±—Ä–∞—É–∑–µ—Ä–æ–º.');
      return;
    }
    watchId = navigator.geolocation.watchPosition(
      (pos)=>{
        const {latitude, longitude, accuracy} = pos.coords;
        status.textContent = tracking ? 'Tracking' : 'Ready';
        acc.textContent = Math.round(accuracy)+' –º';
        const ll = [latitude, longitude];
        userMarker.setLatLng(ll);
        if(points.length===0){ map.setView(ll, 16); }
        if(tracking && inCity(L.latLng(ll[0], ll[1]))){
          pushPoint(latitude, longitude, accuracy);
        }
      },
      (err)=>{
        console.warn(err);
        status.textContent = 'Permission?';
        showPerm(true);
      },
      {enableHighAccuracy:true, maximumAge:5000, timeout:15000}
    );
  }

  function stopWatch(){
    if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; }
  }

  // Initial fog rebuild from saved holes
  if(holes.length){ fogPoly.setLatLngs([OUTER, ...holes]); }
  // Initial progress compute
  updateProgress();

  // ---- UI handlers ----
  btnEnable.addEventListener('click', ()=>{
    showPerm(false);
    startWatch();
    status.textContent='Waiting‚Ä¶';
  });

  btnStart.addEventListener('click', ()=>{
    tracking = true; status.textContent='Tracking';
    startWatch();
  });

  btnPause.addEventListener('click', ()=>{
    tracking = false; status.textContent='Paused';
  });

  btnSetArea.addEventListener('click', ()=>{
    cityBounds = map.getBounds();
    save();
    // optional visual rectangle (flash)
    const r = L.rectangle(cityBounds, {color:'#22c55e', weight:1, fillOpacity:0.03});
    r.addTo(map); setTimeout(()=>map.removeLayer(r), 1200);
    updateProgress();
  });

  btnReset.addEventListener('click', ()=>{
    if(!confirm('–°–∫–∏–Ω—É—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å, –∑–æ–Ω—É, —Ç—Ä–µ–∫ —ñ –¥–∞–Ω—ñ?')) return;
    // Clear state
    holes.length = 0;
    points.length = 0;
    distanceMeters = 0; setDistance(0);
    lastPoint = null; cityBounds = null;
    fogPoly.setLatLngs([OUTER]);
    save(); updateProgress();
  });

  // Try to gently request permissions on load
  setTimeout(()=>{ startWatch(); }, 300);

  // If we have no permission yet, show banner
  setTimeout(()=>{ if(!points.length && !watchId){ showPerm(true);} }, 1200);

  // Persist before unload
  window.addEventListener('beforeunload', save);

})();
</script>
</body>
</html>
